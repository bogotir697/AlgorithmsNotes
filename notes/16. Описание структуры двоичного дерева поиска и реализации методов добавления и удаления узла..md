#### [[Вопросы к Экзамену]]
---
### Описание
Двоичное дерево поиска — это двоичное дерево, на которое наложены следующие ограничения:
- Оба поддерева — левое и правое — являются двоичными деревьями поиска.
- У всех узлов левого поддерева для произвольного узла значения ключей меньше значения ключа этого узла.
- У всех узлов правого поддерева для произвольного узла значения ключей больше либо равны значения ключа этого узла.
Такие ограничения гарантируют логарифмическое время поиска элемента.
### Добавление узла
Алгоритм добавления узла в двоичное дерево поиска описывается в 3 не сложных шага:
1. Создать указатель на корень
2. Если значения нынешнего узла больше значения нового, то перейти к левому потомку, иначе — к правому
3. Если потомок не существует, на это место вставить новый узел, иначе — повторить шаг 2.

```python
def addNode(tree, key):
  node = tree.root
  while (node is not None):
    if node.key < key:
      if node.right is None:
	    node.right = Node(key, parent=node, left=None, right=None)
	    break
	  else:
		node = node.right
    else:
	  if node.left is None:
	    node.left = Node(key, parent=node, left=None, right=None)
	    break
      else:
	    node = node.left
  else:
    tree.root = Node(key, parent=None, left=None, right=None)
```
### Удаление узла
Удаление узла из двоичного дерева поиска это более комплексная операция. Существует несколько возможных ситуаций:
1) У узла нет потомков
2) У узла один потомок
3) У узла есть оба потомка
Если у узла нет наследника, то необходимо просто удалить этот узел, а у его родителя обнулить указатель на него. Это самая простая ситуация.![[tree-delete-Leaf.png]]
Все слегка усложняется, когда у удаляемого узла имеются наследники.![[tree-delete-OneChild.png]]
Если же у удаляемого два наследника, то узел не удаляется, а его значение заменяется на максимум левого поддерева. После этого удаляется максимум левого поддерева.![[tree-delete-TwoChildren.png]]
```python
def deleteNode(tree, node):
  parent = node.parent
  hasParent = parent is not None
  if node.right is None and node.left is None:
    if hasParent and parent.right == node:
	  parent.right = None
	elif hasParent and parent.left == node:
	  parent.left = None
	else:
	  tree.root = None
	del node
  elif node.right is None != node.left is None:
    branch = None
    if node.right is None:
      branch = node.left
	else:
	  branch = node.right
	if hasParent and parent.right == node:
	    parent.right = branch
	  elif hasParent and parent.left == node:
	    parent.left = branch
	  else:
	    tree.root = branch
	  del node
  else:
    maxChild = node.left
    while (maxChild.right):
      maxChild = maxChild.right
    node.key = maxChild.key
    deleteNode(tree, maxChild)
```