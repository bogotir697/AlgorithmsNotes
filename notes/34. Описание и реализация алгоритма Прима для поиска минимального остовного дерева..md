#### [[Вопросы к Экзамену]]
---
### Описание
Алгоритм Прима — алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе.
**Идея:** Будем последовательно строить поддерево $F$ ответа в графе $G$, поддерживая приоритетную очередь $Q$ из вершин $G\backslash F$, в которой ключом для вершины $v$ является $\displaystyle \min_{u\in V(F);uv\in E(G)} w(uv)$ — вес минимального ребра из вершин $F$ в вершины $G\backslash F$. Также для каждой вершины в очереди будем хранить $p(v)$ — вершину $u$, на которой достигается минимум в определении ключа. Дерево $F$ поддерживается неявно, и его ребра — это пары $(v,p(v))$, где $v\in G\backslash\{r\}\backslash Q$, а $r$ — корень $F$. Изначально $F$ пусто и значения ключей у всех вершин равны $+\infty$. Выберём произвольную вершину $r$ и присвоим её ключу значение $0$. На каждом шаге будем извлекать минимальную вершину $v$ из приоритетной очереди и релаксировать все ребра $vu$, такие что $u\in Q$, выполняя при этом операцию $\text{decreaseKey}$ над очередью и обновление $p(v)$. Ребро $(v,p(v))$ при этом добавляется к ответу.
### Реализация
```python
def primFindMST(G):
  Q = PriorityQueue()
  p = {}
  for v in G.vertices:
    v.key = max([e.weight for e in G.edges]) + 1
    p[v] = None
  r = G.vertices[0]
  r.key = 0
  Q.enqueue(G.vertices)
  while not Q.empty():
    v = Q.dequeueMin()
    for vu in G.edges(v):
      if vu.u in Q and u.key > vu.weight:
        p[u] = v
        u.key = vu.weight
        Q.decreaseKey(u, u.key)
  return p
```