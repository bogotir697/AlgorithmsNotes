#### [[Вопросы к Экзамену]]
---
### Алгоритм
- Пока не все токены обработаны:
- Прочитать **токен**.
- Если токен — *число*, то добавить его в очередь вывода.
- Если токен — *функция*, то поместить его в стек.
- Если токен — *разделитель* аргументов функции (например, запятая):
	- Пока токен на вершине стека не _открывающая скобка:_
	    - Переложить оператор из стека в выходную очередь.
	    - Если стек закончился до того, как был встречен токен _открывающая скобка_, то в выражении пропущен _разделитель аргументов функции_ (запятая), либо пропущена _открывающая скобка_.
- Если токен — _оператор_ op1, то:
	- Пока присутствует на вершине стека токен _оператор_ op2, чей приоритет выше или равен приоритету op1, и при равенстве приоритетов op1 является левоассоциативным:
	    - Переложить op2 из стека в выходную очередь;
	- Положить op1 в стек.
- Если токен — _открывающая скобка_, то положить его в стек.
- Если токен — _закрывающая скобка_:
	- Пока токен на вершине стека не _открывающая скобка_
	    - Переложить оператор из стека в выходную очередь.
	    - Если стек закончился до того, как был встречен токен _открывающая скобка_, то в выражении пропущена скобка.
	- Выкинуть _открывающую скобку_ из стека, но не добавлять в очередь вывода.
	- Если токен на вершине стека — функция, переложить её в выходную очередь.
- Если больше не осталось токенов на входе:
	- Пока есть токены операторы в стеке:
		- Если токен оператор на вершине стека — _открывающая скобка_, то в выражении пропущена скобка.
		- Переложить оператор из стека в выходную очередь.

- Конец.
### Реализация
```python
def sortingStation(s: str) -> Queue:
	functions = {'sin':10, 'cos':10, 'ln':10}
	operators = {'+':1, '-':1, '*':2, '/':2, '^':3}
	tokens = {'(':0, ')':0, ',':0} | operators | functions
	token = ''
	output = Queue()
	stack = Stack()
	s = s.replace(' ', '')
	for c in s:
		if token not in tokens.keys():
			if c.isdigit() != token.isdigit():
				if token.isdigit():
					output.enqueue(token)
					token = c
			else:
				token += c
				if c.isdigit():
					continue
		if token in tokens.keys():
			weight = tokens[token]
			if weight:
				while (not stack.empty()) and tokens[stack.peek()] >= weight:
					output.enqueue(stack.pop())
				stack.push(token)
			elif token == '(':
				stack.push(token)
			elif token == ',':
				while (not stack.empty()) and stack.peek() != '(':
					output.enqueue(stack.pop())
				if stack.empty():
					raise ValueError("Cannot find '(' on top of stack")
			else:
				while (not stack.empty()) and stack.peek() != '(':
					output.enqueue(stack.pop())
				if (not stack.empty()) and stack.peek() == '(':
					stack.pop()
				else:
					raise ValueError("Cannot find '(' on top of stack")
				if (not stack.empty()) and stack.peek() in functions.keys():
					output.enqueue(stack.pop())
			token = ''
		if c.isdigit():
			token += c
	if token.isdigit():
		output.enqueue(token)
	while not stack.empty():
		output.enqueue(stack.pop())
	return output
```
