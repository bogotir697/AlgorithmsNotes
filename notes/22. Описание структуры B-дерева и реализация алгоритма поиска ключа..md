#### [[Вопросы к Экзамену]]
---
### B-дерево
B-дерево — cамобалансирующееся дерево поиска. В отличие от АВЛ-дерева или КЧ-дерева каждый узел B-дерева может иметь несколько ключей, которые используются для поиска элемента.
![[Btree.png]]
Для B-дерева справедливы следующие ограничения:
- Каждый узел может иметь до $m$ дочерних узлов.
- Каждый нелистовой узел (кроме корневого) имеет как минимум $\lceil{m/2}\rceil$ узлов.
- Корневой узел имеет минимум 2 дочерних узла, за исключением случая, когда он является и листовым.
- Нелистовой узел с $k$ дочерними узлами содержит $k - 1$ ключ.
- Глубина всех листов одинакова.

Для каждого узла дерева справедливы утверждения:
- Ключи узла $x$ — $x.key_1, x.key_2,\ldots, x.key_n$ хранятся в неубывающем порядке: $x.key_1 \leqslant x.key_2 \leqslant \dots \leqslant x.key_n$.
- Каждый внутренний узел также содержит $n+1$ указателей $c.key_1, c.key_2,\ldots, c.key_{n+1}$ на дочерние узлы. Листовые узлы не имеют потомков, поэтому не содержат указателей.
- Ключи $x.key_i$ ограничивают диапазон возможных ключей, хранящихся в каждом поддереве: пусть $k_i$ произвольный ключ в поддереве некоторого узла $x$, тогда: $k_1 \leqslant x.key_1 \leqslant k_2 \leqslant x.key_2 \leqslant ... \leqslant x.key_n \leqslant k_{n+1}$.
- Узел имеет минимальное и максимальное число элементов, которое он может хранить. Определим эти числа через целое число $t \geqslant 2$, называемое **степенью** B-дерева, тогда:
    1. Каждый узел кроме корневого должен иметь, по крайней мере, $t-1$ ключей. Каждый внутренний узел кроме корневого в таком случае хранит по крайней мере $t$ узлов. Если дерево непустое, то узел должен иметь как минимум один ключ.
    2. Каждый узел может иметь до $2t - 1$ ключей. Поэтому, внутренний узел может содержать максимум $2t$ узлов. Узлы, содержащие ровно $2t - 1$ ключей являются _полными_
### Поиск ключа
Чтобы найти ключ в дереве достаточно выполнить следующую последовательность действий:
1. Загрузить очередной блок (узел) в память с диска.  
2. Используя линейный поиск, найти наименьший индекс $i$ ключа для которого справедливо, что $k \leqslant x.key_i$.  
3. Если при этом $k = x.key_i$, то искомый элемент найден и алгоритм заканчивает свою работу.  
4. Если узел листовой, то элемент не найден и алгоритм заканчивает работу. В противном случае загрузить блок по адресу $c.key_i$ и перейти к п. 2.
```python
def Btree_search(node, key):
  i = 1
  while i <= len(node.keys) and key >= node.keys[i]:
    i += 1
  if i <= len(node.keys) and key == node.keys[i]:
    return (node, i)
  elif node.leaf:
    return None
  else:
    read_child(node, i)
    return Btree_search(node.child[i], key)
```