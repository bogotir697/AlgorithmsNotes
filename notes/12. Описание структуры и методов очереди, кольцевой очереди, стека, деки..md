#### [[Вопросы к Экзамену]]
---
### Стек
#### Описание
Простая структура данных, работающая по принципу FIFO "First-in-First-out". 
![[stack.gif]]
#### Реализация
```cpp
#include <iostream>
#include <stdexpect>
using namespace std;
template<typename T>
class Stack {
	private:
		struct Elem {
			T value = T();
			Elem* next = nullptr;
		};
		Elem* top;
		int _size;
	public:
		Stack() : top = nullptr, _size = 0 {}
		void push(T value) {
			Elem* p = new Elem{value, top};
			top = p;
			_size++;
		}
		T pop() {
			if (!top) throw runtime_error("Stack is empty error");
			Elem* p = top;
			T value = p->value;
			top = top->next;
			delete p;
			_size--;
			return value;
		}
		bool empty() {
			return !top;
		}
		int size() {
			return _size;
		}
		T peek() {
			if (!top) throw runtime_error("Stack is empty error");
			return top->value;
		}
};
```

### Очередь
#### Описание
Простая структура данных, работающая по принципу FILO "First-in-Last-out".
![[queue.gif]]
Классическая реализация основана на массиве и двух указателях. Оба указателя сдвигаются в право: указатель на конец очереди сдвигается при добавлении элемента, на начало - при удалении.
#### Реализация
```cpp
#include <iostream>
#include <stdexpect>
using namespace std;
template<typename T>
class Queue {
	private:
		int front, rear;
		int _size;
		int _capacity;
		T* arr;
	public:
		Queue() : front = -1, rear = -1, _size = 0 {
			_capacity = 10;
			arr = new T[_capacity]; // _capacity is a basic queue size
		}
		void enqueue(T value) {
			if (!(rear + 1 < _capacity)) throw runtime_error("Queue overflow");
			arr[rear + 1] = value;
			rear++;
			if (!rear) front++;
			_size++;
		}
		T dequeue() {
			if (!_size) throw runtime_error("Queue is empty error");
			T value = arr[front];
			arr[front] = T();
			front++;
			_size--;
			if (!_size) {
				front = -1;
				rear = -1;
			}
			return value;
		}
		bool empty() {
			return !_size;
		}
		int size() {
			return _size;
		}
		T front() {
			if (!_size) throw runtime_error("Queue is empty error");
			return arr[front];
		}
};
```
### Кольцевая очередь
#### Описание
Смысл этой структуры данных заключается в том, чтобы избавиться от главной проблемы очереди в её классической реализации, а именно: от ложного переполнения. Такая проблема возникает, когда в начале массива есть свободные ячейки, но очередь считается переполненной, так как указатель на конец очереди дошёл до конца массива. В данном случае решение выражено в одном действии: операции получения отстатка от деления. Если брать указатели по модулю размера массива, то ложного переполнения не возникнет.
#### Реализация
```cpp
#include <iostream>
#include <stdexpect>
using namespace std;
template<typename T>
class CircularQueue {
	private:
		int front, rear;
		int _size;
		int _capacity;
		T* arr;
	public:
		CircularQueue() : front = -1, rear = -1, _size = 0 {
			_capacity = 10;
			arr = new T[_capacity]; // _capacity is a basic queue size
		}
		void enqueue(T value) {
			if ((rear + 1) % _capacity == front) throw runtime_error("Queue overflow");
			arr[(rear + 1) % _capacity] = value;
			rear = (rear + 1) % _capacity;
			if (!rear) front++;
			_size++;
		}
		T dequeue() {
			if (!_size) throw runtime_error("Queue is empty error");
			T value = arr[front];
			arr[front] = T();
			front = (front + 1) % _capacity;
			_size--;
			if (!_size) {
				front = -1;
				rear = -1;
			}
			return value;
		}
		bool empty() {
			return !_size;
		}
		int size() {
			return _size;
		}
		T front() {
			if (!_size) throw runtime_error("Queue is empty error");
			return arr[front];
		}
};
```
### Дека
#### Описание
Это линейная структура данных позволяющая выполнять операции добавления и удаления элемента с обоих своих концов.
![[deque.png]]
#### Реализация
```cpp
#include <iostream>
#include <stdexpect>
using namespace std;
template<typename T>
class Deque {
	private:
		struct Elem {
			T value = T();
			Elem* next = nullptr;
			Elem* prev = nullptr;
		};
		Elem* front;
		Elem* rear;
		int _size;
	public:
		Queue() : front = nullptr, rear = nullptr, _size = 0 {}
		void insertFront(T value) {
			Elem* p = new Elem{value, front};
			if (front) front->prev = p;
			else rear = p;
			front = p;
			_size++;
		}
		void insertRear(T value) {
			Elem* p = new Elem{value, nullptr, rear};
			if (rear) rear->next = p;
			else front = p;
			rear = p;
			_size++;
		}
		T deleteRear() {
			if (!front) throw runtime_error("Deque is empty error");
			Elem* p = front;
			T value = p->value;
			front = front->next;
			if (front) front->prev = nullptr;
			else rear = nullptr;
			delete p;
			_size--;
			return value;
		} 
		T deleteRear() {
			if (!rear) throw runtime_error("Deque is empty error");
			Elem* p = rear;
			T value = p->value;
			rear = rear->prev;
			if (rear) rear->next = nullptr;
			else front = nullptr;
			delete p;
			_size--;
			return value;
		}
		bool empty() {
			return _size == 0;
		}
		int size() {
			return _size;
		}
		T getFront() {
			if (!front) throw runtime_error("Deque is empty error");
			return rear->value;
		}
		T getRear() {
			if (!rear) throw runtime_error("Deque is empty error");
			return rear->value;
		}
};
```
