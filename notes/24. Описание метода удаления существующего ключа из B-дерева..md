#### [[Вопросы к Экзамену]]
---
Легко понять, что для удаления ключ из дерева достаточно провести процедуру обратную к добавлению. Важно, что при удалении существует возможность удалить ключ из любого узла, а не только листового. Тогда для удаления ключа необходимо для каждого узла, начиная от корневого, проверять следующие шаги: ![[Btree-delete-init.png]]
1. Если ключ $k$ находится в узле $x$, являющийся листом, то удалить ключ $k$ из $x$:![[Btree-delete-case1.png]]
2. Если ключ $k$ находится в узле $x$, являющимся внутренним узлом, то:
	- a) Если дочерний элемент $y$, который предшествует ключу $k$ в узле $x$, содержит как минимум $t$ ключей, тогда найти в поддереве узла $y$ элемент $k'$, предшествующий $k$. Рекурсивно удалить $k'$ и заменить $k$ на $k'$ в узле $x$. ![[Btree-delete-case2a.png]]
	- b) Если в $y$ меньше $t$ ключей, то проверить дочерний элемент $z$, который следует за $k$ в узле $x$. Выполнить аналогичную **случаю 2a** проверку ключа, который идёт следующим по порядку после ключа $x$.
	- с) Если оба потомка $y$ и $z$ содержат только $t-1$ ключ, то добавить $k$ и все ключи $z$ в $y$, после чего из $x$ пропадают $k$ и ссылка на $z$, а $y$ содержит теперь ровно $2t-1$ ключей. После чего освободить $z$ и рекурсивно удалить $k$ из $y$. ![[Btree-delete-case2c.png]]
3. Если ключа $k$ нет во внутреннем узле $x$, то находим поддерево $x.c_i$, которое должно содержать ключ $k$ (если оно вообще есть в дереве). Если $x.c_i$ содержит только $t-1$ ключей, то выполнить $3a$ или $3b$ как необходимые шаги, чтобы гарантировать, что мы переходим к узлу, содержащему как минимум $t$ ключей. Затем рекурсивно вызвать удаление ключа $k$ из соответствующего дочернего узла.
	- a) Если $x.c_i$ содержит только $t-1$ ключ, но при этом имеет непосредственного соседа с не менее чем $t$ ключами, то добавить в $x.c_i$ дополнительный ключ путём перенса ключа $x$ вниз в $x.c_i$, а из соседского узла (справа или слева) перенести ключ в $x$ и обновить ссылку
	- b) Если $x.c_i$ и оба непосредственных соседа $x.c_i$ содержат $t-1$ ключ, то объединить $x.c_i$ с одним из соседних узлов, что влечёт перемещение ключа из $x$ вниз в новый объединённый узел и делает его медианным ключом для этого узла
	![[Btree-delete-case3.png]]