#### [[Вопросы к Экзамену]]
---
### Описание
Это эффективный алгоритм поиска подстроки в строке, основывающийся на префикс функции `prefix[i]`, которая вычисляет для $i$ масимальную длину совпадающих суффикса(подстроки, первый символ которой совпадает с первым символом текста) и префикса(подстроки, последний символ которой находится на $i$-й позиции). Звучит сложно, вот рисунок:
![[KMP.png]]
Цифрами обозначены значения префикс функции для каждой позиции. Над строкой скобка выделяет суффикс, под строкой - префикс, каждый префикс соотносится с суффиксом того же цвета.

Как же всё-таки вычислить префикс-функцию? Если пойти самым наивным путём, и перебирать все возможные варианты в каждой позиции, то сложность будет $O(n^2)$, — а это слишком долго. Конечно есть другой путь, но для него нужно кое-что заметить: если следующий символ префикса равен следующему символу суффикса, то результат префикс функции на единицу больше предыдущего. Для того, чтобы стало понятнее, придётся ввести некоторые обозначения:
Пусть `M[i]` — это результат префикс функции для `i`, `C[i]` — это символ под индексом `i`, `P(i)` — это максимальный префикс, его можно определить как срез `C[i + 1 - M[i]:i + 1]`, `S(i)` — это максимальный суффикс, его можно определить как срез `C[0:M[i]]`. 
Так вот если символ `C[i+1]` равен символу `C[M[i]]`, то `P(i+1)` равен `S(i+1)`, так как `P(i+1) = P(i) + C[i+1]`, а `S(i+1) = S(i)+C[M[i]]` (мы увеличили строку на один символ, увеличили максимальные префикс и суффикс в предыдущей строке на один символ и они остались равны, значит увеличенные префикс и суффикс являются максимальными в новой строке). 
Хорошо, а что если символы не совпадут? Как тогда быстро найти значение префикс функции? Подходящим вариантом будет решение прикинуть "а подойдёт ли символ для более короткого префикса". Вот, что я имею в виду: если `C[i+1]` не подошёл в качестве (`M[i] + 1`)-го символа, то возможно он подойдёт в качестве (`M[M[i] - 1] + 1`)-го. Откуда вообще взялось `M[M[i] - 1]`? Это значение префикс функции для последнего символа суффикса длины `M[i]`, по сути мы таким образом узнаём, сколько символов взять перед текущим, чтобы получился подходящий префикс. Мы этот шаг `j = M[j - 1]` проводим до тех пор, пока `j > 0` и `C[j] != C[i + 1]`, если символы так и не становятся равны, мы просто оставляем `0`.
### Реализация
```python
def KMP(s: str, sub: str):
	c = sub + '@' + s
	prefix = [0]*len(c)
	for i in range(1, len(c)):
		j = prefix[i - 1]
		while j > 0 and c[j] != c[i]:
			j = prefix[j - 1]
		if c[j] == c[i]:
			prefix[i] = j + 1
		if prefix[i] == len(sub):
			return i
	return -1
```