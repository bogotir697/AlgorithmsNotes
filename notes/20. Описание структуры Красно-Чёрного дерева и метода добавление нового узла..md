#### [[Вопросы к Экзамену]]
---
### Красно-Чёрное дерево
КЧ-деревья — это сбалансированные деревья поиска, в которых каждый узел дополнительно хранит свой цвет. Для красно-чёрного дерева выполнены следующие свойства:
1. каждый узел либо красный, либо чёрный;
2. каждый лист (фиктивный) – чёрный;
3. если узел красный, то оба его сына – чёрные;
4. все пути, идущие от корня к любому фиктивному листу, содержат одинаковое количество чёрных узлов;
5. корень – чёрный.
Чёрная высота узла — количество чёрных узлов на пути от узла к узлу, у которого оба сына — фиктивные листья
### Добавление узла
Всё начинается со стандарной вставки в двоичное дерево поиска. Новый узел красится в красный.
- Если новый узел является корнем дерева, он перекрашивается в чёрный
- Если родитель нового узла красный, то нарушено *св. 3* (красно-красное нарушение). Обозначим новый узел за $X$, родителя за $F$, его деда за $G$, а другого сына деда — дядю — за $U$.
	1. Дядя $U$ — красный
		- В таком случае достаточно перекрасить отца $F$ и дядю $U$ в чёрный, а деда $G$ — в красный. ![[RBtree-insert-redU.png]]
		- Если отец деда $G$ — красный, то возникает новое красно-красное нарушение, и придётся продолжить восстанавливать свойства КЧ-дерева, но в роли $X$ будет дед $G$ нового узла
	2. Дядя $U$ — чёрный, а цепочка узлов $X-F-G$ — образует прямую
		- Нужно выполнить малый поворот деда $G$ относительно отца $F$ и перекрасить отца $F$ в чёрный, а деда $G$ — в красный. ![[RBtree-insert-blackU-line.png]]
	3. Дядя $U$ — чёрный, а цепочка узлов $X-F-G$ образует угол
		- Перекрасив новый узел $X$ в чёрный, а деда $G$ — в красный, получим новое красно-красное нарушение. Ситуацию решит большой поворот цепочки $X-F-G$. ![[RBtree-insert-blackU-angle.png]]
```python
def RB_insert(tree, key): # на вход подаётся дерево и ключ узла
  x = addNode(tree, key)
  x.color = 'red'
  while x != tree.root and x.parent.color == 'red':
    if x.parent == x.parent.parent.left:
      u = x.parent.parent.right # u - дядя x
      if u.color == 'red': # случай 1
        x.parent.color = 'black'
        u.color = 'black'
        x.parent.parent.color = 'red'
        x = x.parent.parent # следующая итерация с дедом x
      else:
        if x == x.parent.right: # случай 3
          # случай 2
          x = x.parent
          rotateL(T, x)
        x.parent.color = 'black' # случай 2
        x.parent.parent.color = 'red'
        rotateR(tree, x.parent.parent)
    else:
      # симметричный фрагмент с заменой left <-> right
      pass
  tree.root.color = 'black'
```