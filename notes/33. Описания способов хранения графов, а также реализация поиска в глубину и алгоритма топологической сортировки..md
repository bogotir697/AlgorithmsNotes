#### [[Вопросы к Экзамену]]
---
Граф — нелинейная структура данных, состоящая из вершин (узлов) и рёбер (связей), которые их соединяют, моделируя отношения между объектами.
<div style="background-color:white; display:flex; width:fit-content; border-radius: 10px">
	<div style="margin: 5px">
		<img src="../img/graph.png">
	</div>
</div>
### Способы представления графа
1. Списки смежности
	```python
	[a] -> a:2 -> b:5 -> d:8
	[b] -> c:7 -> d:9
	[c] -> d:4
	[d] -> c:3
	```
2. Списки рёбер
	```python
	[a,a,2]
	[a,b,5]
	[a,d,8]
	[b,c,7]
	[b,d,9]
	[c,d,4]
	[d,c,3]
	```
3. Матрицы смежности
	```python
	   a  b  c  d
	a  2  5  0  8
	b  0  0  7  9
	c  0  0  0  4
	d  0  0  3  0
	```
4. Матрицы идентичности
	```python
	       a  b  c  d
	(a,a)  2  0  0  0
	(a,b)  0  5  0  0
	(a,d)  0  0  0  8
	(b,c)  0  0  7  0
	(b,d)  0  0  0  9
	(c,d)  0  0  0  4
	(d,c)  0  0  3  0
	```

*Списки смежности* и *списки рёбер* являются компактными и удобными в том случае, когда граф является разреженным. В случае со списком смежности хранение представляет собой массив вершин графа, для каждой из которых определены все вершины в которые можно попасть из неё.

*Матрица смежности* и *матрица идентичности* являются более удобным представлением в том случае, если огда нужно быстро отвечать на вопрос «является ли данное ребро инцидентно к…» или аналогичные. Но, если графы не плотные (а разреженные), то занимается существенное количество памяти. 
*Матрица смежности* состоит из таблицы размером $|V| \times |V|$, где на пересечении для каждой пары вершин находится или признак того, что ребро между ними существует (для неориентированных графов), либо вес ребра. 
*Матрица инцидентности* имеет размер $|V| \times |E|$, а её пересечении говорит о том, что данное ребро инцидентно вершине (то есть один из её концов содержит вершину). В случае ориентированного графа в матрице смежности используются положительные числа для того, чтобы обозначить, что ребро выходит из этой вершины.
### Поиск в глубину
Суть алгоритм заключается в том, что мы пытаемся пройти максимально глубоко по одной ветви потомков вершины, прежде переходить к остальным. Реализация этого алгоритма основывается на стэке, в который помещаются потомки вершины, если они ещё не были пройдены.
```python
def DFS(graph, s):
  stack = Stack()
  stack.push(s)
  visited = []
  visited.append(s)
  while not stack.empty():
    v = stach.pop()
	visited.append(v)
	visit(v)
	for u in graph[v]:
	  if u not in visited and u not in stack:
	    stack.push(u)
      
```
### Топологическая сортировка
Задача топологической сортировки состоит в следующем: указать такой линейный порядок на его вершинах, чтобы любое ребро вело от вершины с меньшим номером к вершине с большим номером. Очевидно, что если в графе есть циклы, то такого порядка не существует.  
_Ориентированной сетью_ (или просто сетью) называют бесконтурный ориентированный граф. В задачах подобного плана рассматриваются только конечные сети.
![[graph-topologySort.png]] Пример графа, подходящего для топологической сортировки.
Одним из методов реализации топологической сортировки основывается на обходе в глубину. В данном случае необходимо после посещения вершины добавить её в очередь, из которой после окончания обхода в глубину будут вытащены все вершины. Порядок доставания вершин будет соответствовать их новым номерам.
```python
def topologicSort(graph,s):
  stack = Stack()
  queue = Queue()
  stack.push(s)
  visited = []
  visited.append(s)
  while not stack.empty():
    v = stach.pop()
	visited.append(v)
	visit(v)
	queue.enqueue(v)
	for u in graph[v]:
	  if u not in visited and u not in stack:
	    stack.push(u)
  while not queue.empty():
    yield queue.dequeue()
```