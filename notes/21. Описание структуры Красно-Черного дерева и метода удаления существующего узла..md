#### [[Вопросы к Экзамену]]
---
### Красно-Чёрное дерево
КЧ-деревья — это сбалансированные деревья поиска, в которых каждый узел дополнительно хранит свой цвет. Для красно-чёрного дерева выполнены следующие свойства:
1. каждый узел либо красный, либо чёрный;
2. каждый лист (фиктивный) – чёрный;
3. если узел красный, то оба его сына – чёрные;
4. все пути, идущие от корня к любому фиктивному листу, содержат одинаковое количество чёрных узлов;
5. корень – чёрный.
Чёрная высота узла — количество чёрных узлов на пути от узла к узлу, у которого оба сына — фиктивные листья
### Удаление узла
Всё начинается со стандартного удаления узла из двоичного дерева поиска.
- Потомков нет — узел просто удаляется
- Потомок один — потомок занимает место удалённого узла
- Потомка два — значение узла заменяется на максимум левого поддерева и после удаляется максимальный узел левого поддерева. Это позволяет перейти к более простому случаю
Далее начинается второй этап удаления: восстановление свойств КЧ-дерева.
- Если удаляемый узел красный, то свойства КЧ-дерева не будут нарушены.
- Если удаляемый узел чёрный, а его сын красный, то достаточно перекрасить сына в чёрный.
- Если удаляемый узел чёрный, а дерево любой другой вид, то возможно несколько случаев. Сын удалённого узла чёрный, обозначим его за $N$, отца за $F$. После удаления $F$ стал новым отцом $N$. $B$ — новый брат $N$, а $CL$ и $CR$ — левый и правый сыновья $B$.
	1. Отец $F$ красный, остальные узлы чёрные.
		- Наиболее простой случай. Достаточно перекрасить узлы $F$ и $B$ в противоположные цвета. ![[RBtree-delete-redF-all-black.png]]
	2. Брат $B$ чёрный, $CR$ красный.
		- В этом случае не важно, какого цвета $F$, свойства восстановятся после малого поворота $F$ относительно $B$, перекраски $CR$ в чёрный и обмена цветами $F$ и $B$. ![[RBtree-delete-blackB-redCR.png]]
	3. Брат $B$ чёрный, $CR$ чёрный, а $CL$ красный.
		- Этот случай сводится к предыдущему, если совершить малый поворот $B$ относительно $CL$. Тогда поддерево $B$ станет выглядеть как прямая $CL-B-CR$ и после перекрашивания $CL$ и $B$ у $N$ будет чёрный брат с красным правым сыном. ![[RBtree-delete-blackB-blackCR-redCL.png]]
	4. Брат $B$ красный.
		- В этом случае $F$, $CL$ и $CR$ могут быть только чёрными. Если совершить малый поворот $F$ относительно $B$ и перекрасить их в противоположные цвета, то этот случай сведётся к одному из первых трёх, так как брат узла $N$ будет чёрным. ![[RBtree-delete-redB.png]]
	5. Все узлы чёрные.
		- В этом случае достаточно перекрасить $B$ в красный. ![[RBtree-delete-all-black.png]]
		-  Но нужно учесть, что у $F$ могут быть предки, а количество чёрных узлов во всех путях $F$ уменьшилось на 1. В таком случае нужно продолжить процедуру восстановления свойств КЧ-дерева, но в роли $N$ будет узел $F$. 
```python
def RB_deleteFix(tree, n):
  while n != tree.root and n.color == 'black':
    if n == n.parent.left:
      b = n.parent.right # b - брат n
      if b.color == 'red': # случай 4
        b.color = 'black'
        n.parent.color = 'red'
        rotateL(tree, n.parent)
        b = n.parent.right # теперь у n чёрный брат
      if b.left.color == 'black' and b.right.color == 'black': # случай 1 или 5
        b.color = 'red'
        n = n.parent # если n красный, то это случай 1, если чёрный, то случай 5
      else:
        if b.right.color == 'black': # случай 3
          # сводим к случаю 2
          b.left.color = 'black'
          b.color = 'red'
          rotateR(tree, b)
          b = n.parent.right
        b.color = n.parent.color # случай 2
        n.parent.color = 'black'
        b.right.color = 'black'
        rotateL(tree, n.parent)
        n = tree.root # при попытке зайти в цикл всё закончится
    else:
      # симметричный фрагмент с заменой left <-> right
      pass
  n.color = 'black'

def RB_deleteNode(tree, key): # на вход подаётся дерево tree и key
  z = find(tree, key)
  if z.left is None or z.right is None: # один из сыновей z - фиктивный лист
    y = z
  else:
    y = findMax(z.left)
  if y.left is not None:
    x = y.left
  else:
    x = y.right
  x.parent = y.parent
  if y.parent is None:
    tree.root = x
  else:
    if y == y.parent.left:
      y.parent.left = x
    else:
      y.parent.right = x
  if y != z:
    z.key = y.key
  if y.color == 'black':
    RB_deleteFix(tree, x)
  del y
  
```