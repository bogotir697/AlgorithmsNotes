#### [[Вопросы к Экзамену]]
---
### Описание
Ассоциативный массив — это абстрактный тип данных, позволяющий хранить пары вида <ключ, значение> и поддерживающий операции хранения пары, а также поиска и удаления пары по ключу. Предполагается, что в массиве не может быть двух пар с одинаковыми ключами.

Один из вариантов реализации этого типа данных — это хэш-таблица. Принцип работы этой структуры данных основывается на хэш-функции — функции, вычисляющая хэш (какое-то большое число) относительно какого-то значения. В хэш-функцию передаётся ключ, а она возвращает индекс в динамическом массиве. Сама хэш-таблица представляет собой динамический массив односвязных списков — это вызвано тем, что иногда случаются коллизии (хэш-функция возвращает одинаковый хэш для разных значений). Представление этой структуры данных через динамический массив односвязных списков называется *"Методом цепочек"*. Каждый элемент хранит пару <ключ, значение>.
**Теперь кратко опишем работу методов:**
Получение элемента по ключу:
1. Получить индекс из ключа используя хэш-функцию.
2. Попытаться найти элемент с подходящим ключом.
3. Если элемент не найден, то возвращяем NULL, если найден — ассоциируемое с ключом значение.

Добавление элемента:
1. Получить индекс из ключа используя хэш-функцию.
2. Проверить список по индексу.
3. Если в списке есть элемент с таким же ключом, то обновить его значение, если нет — добавить его в список.

Удаление элемента:
1. Получить индекс из ключа используя хэш-функцию.
2. Проверить список по индексу.
3. Если в списке есть подходящий элемент — удалить его, если нет — ничего не делать.
### Реализация
```cpp
template<typename Key, typename Val>
class HashTable {
	private:
		struct Node {
			Key key;
			Val value;
			Node* next = nullptr;
		};
		Node** table;
		int capacity;
		int hash(Key key) {
			int hs = 0;
			// Hash-function
			return hs % capacity;
		}
	public:
		HashTable() : capacity = 50 {
			Node** table = new Node*[capacity];
			for (int i = 0; i < capacity; i++) table[i] = nullptr;
		}
		~HashTable() {
			for (Node* node : table) {
				if (node) {
					Node* p = node;
					while (p->next) {
						Node* temp = p;
						p = p->next;
						delete temp;
					}
				}
			}
			delete table[];
		}
		Val find(Key key) {
			int index = hash(key);
			Node* p = table[index];
			if (!p) return Val();
			while (p->next && p->key != key) p = p->next;
			if (p->key != key) return Val();
			return p->value;
		}
		void insert(Key key, Val value) {
			int index = hash(key);
			Node* node = new Node{key, value};
			if (!table[index]) {
				table[index] = node;
			}
			else {
				Node* p = table[index];
				while (p->next && p->key != key) p = p->next;
				if (p->key == key) {
					p->value = value;
					delete node;
				}
				else { 
					p->next = node; 
				}
			}
		}
		void remove(Key key) {
			int index = hash(key);
			Node* p = table[index];
			Node* prev = nullptr;
			if (!p) return;
			while (p->next && p->key != key) {
				prev = p;
				p = p->next;
			}
			if (p->key != key) return;
			if (prev) prev->next = p->next;
			else table[index] = nullptr;
			delete p;
		}
};
```