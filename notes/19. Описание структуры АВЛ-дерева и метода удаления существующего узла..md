#### [[Вопросы к Экзамену]]
---
### АВЛ-дерево
АВЛ-дерево — это сбалансированное дерево поиска, в котором для любого узла высоты его левого и правого поддеревьев отличаются не больше, чем на единицу. В случае, когда разница между высотами правого и левого поддерева оказывается больше единицы, выполняется соответствующий поворот. В каждом узле АВЛ-дерева, помимо ключа и указателей на поддеревья, хранится показатель баланса — разность высот правого и левого поддерева.
### Удаление узла
Удаление узла из АВЛ-дерева происходит также, как и удаление узла из двоичного дерева поиска: 
- Потомков нет — узел просто удаляется
- Потомок один — потомок занимает место удалённого узла
- Потомка два — значение узла заменяется на максимум левого поддерева и после удаляется максимальный узел левого поддерева. Это позволяет перейти к более простому случаю
Единственное, что меняется, это то, что после удаления может произойти разбалансировка и нужно пройтись от удалённого узла до корня и сбалансировать дерево в каждом узле на пути, если это будет необходимо.
Так можно представить схему поворотов для балансировки, где соответствующее дерево больше соседнего:
- Левое поддерево левого потомка — малый правый поворот.
- Правое поддерево левого потомка — большой правый поворот.
- Правое поддерево правого потомка — малый левый поворот.
- Левое поддерево правого потомка — большой левый поворот.
```python
def balance(tree, node):
  updateHeight(node)
  if node.balance < -1:
      if node.left.left.balance <= -1:
        rotateR(tree, node)
      else:
        rotateLR(tree, node)
    elif node.balance > 1:
      if node.right.right.balance >= 1:
        rotateL(tree, node)
      else:
        rotateRL(tree, node)

def AVL_deleteNode(tree, key):
  node = find(tree, key)
  node = node.parent
  deleteNode(tree, key)
  while node is not None:
    balance(tree, node)
    node = node.parent
```