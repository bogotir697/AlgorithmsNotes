#### [[Вопросы к Экзамену]]
---
### Описание
Суть структуры двусвязного списка заключается в том, что элементы списка разбросаны по разным участкам памяти и связаны между собой указателями. При таком устройстве для добавления и удаления элементов достаточно изменить указатели соседних элементов и не нужно ничего перемещать в памяти. Структура хранит *голову списка* (указатель на *первый* элемент), *хвост списка* (указатель на *последний* элемент) и *размер* (*количество* элементов), но если под последнее не выделять отдельное поле, то операцию получения размера списка можно описать так:
1. Создать переменную-счётчик и временный указатель на голову списка.
2. Перемещать указатель на следующий элемент и увеличивать счётчик на единицу до тех пор, пока существует следующий элемент.

Основных операций насчитывается три: получение, добавление и удаление элемента, - описание алгоритма первой из перечисленных можно предстваить так:
1. Определить, откуда ближе "идти": с головы или с хвоста, - и создать временный указатель, равный подходящей "стартовой позиции".
2. Перемещать указатель либо на следующий (на предыдущий) элемент массива до тех пор, пока счётчик не будет равняться искомому индексу. Изначальное значение счётчика равно индексу *первого* (*последнего*) элемента и на кажном шаге он *увеличивается* (*уменьшается*).

Добавление и удаление элемента это более сложные операции выполняющиеся по разному в зависимости от индекса элемента и размера списка. 
Рассмотрим самый простой вариант добавления элемента: когда список пуст, - в таком случае указатели на *голову* и *хвост* списка просто становятся равны новому элементу.
Добавление элемента **внутрь** списка уже сложнее, для этого нужно:
1. Найти элемент под нужным индексом.
2. Создать новый элемент
3. Указатель на следующий элемент приравнять к найденному, а на предыдущий - к указателю вышеописанного элемента на предыдущий.
4. Поменять указатели соседей так, чтобы они указывали на новый элемент.
![[BiLinkedList-AddElement.gif]]
В случае, когда нужно добавить элемент в начало списка меняется только то, что указатель на предыдущий элемент становится равен нулю, а указатель на *голову списка* становится равен новому элементу. А вот случай добавления элемента в конец списка отличается чуть больше: у нас нет элемента с индексом, равным размеру массива. В этом случае мы просто вставляем новый элемент после последнего элемента списка и перемещаем указатель на *хвост* на него.

Теперь рассмотрим удаление элемента из **середины** списка, алгоритм такой:
1. Найти элемент под нужным индексом.
2. Поменять указатели соседей элемента так, чтобы они указывали друг на друга.
3. Удалить элемент.
![[BiLinkedList-RemoveElement.gif]]
Случаи удаления элемента из концов списка не сильно отличаются друг от друга, в них после удаления нужно переместить соответствующие указатели (на *голову* или *хвост*) на новые крайние элементы.
### Реализация
```cpp
#include<iostream>
#include<stdexcept>
using namespace std;
template<typename T>
class List {
	private:
		int _size = 0;
		struct Elem {
			T value = T();
			Elem* next = nullptr;
			Elem* prev = nullptr;
		};
		Elem* head = nullptr;
		Elem* tail = nullptr;
	public:
		List() : _size = 0, head = nullptr, tail = nullptr {}
		~List() {
			Elem* p = head;
			while (p) {
				Elem* temp = p;
				p = p->next;
				delete temp;
			}
			_size = 0;
			head = nullptr;
			tail = nullptr;
		}
		int size() {
			return _size;
		}
		void add(T value, unsigned int i) {
			if (!(i <= _size)) throw runtime_error("Non-valid index error");
			Elem* newElem = new Elem{value};
			if (i != _size) {
				Elem* p;
				if (i <= _size - 1 - i) {
					p = head;
					for (int j = 0; j <= i; j++) p = p->next;
				}
				else {
					p = tail;
					for (int j = _size - 1; j >= i; j--) p = p->prev;
				}
				newElem->next = p;
				newElem->prev = p->prev;
				p->prev = newElem;
				if (newElem->prev) newElem->prev->next = newElem;
				else head = newElem;
			}
			else {
				newElem->prev = tail;
				if (tail) tail->next = newElem;
				else head = newElem;
				tail = newElem;
			}
			_size++;
		}
		T remove(unsigned int i) {
			if (!(i < _size)) throw runtime_error("Non-valid index error");
			Elem* p;
			if (i <= _size - 1 - i) {
				p = head;
				for (int j = 0; j <= i; j++) p = p->next;
			}
			else {
				p = tail;
				for (int j = _size - 1; j >= i; j--) p = p->prev;
			}
			if (p->prev) p->prev->next = p->next;
			else head = p->next;
			if (p->next) p->next->prev = p->prev;
			else tail = p->prev;
			delete p;
			_size--;
			if (!_size) {
				head = nullptr;
				tail = nullptr;
			}
		}
		T& get(unsigned int i) {
			if (!(i < _size)) throw runtime_error("Non-valid index error");
			Elem* p;
			if (i <= _size - 1 - i) {
				p = head;
				for (int j = 0; j <= i; j++) p = p->next;
			}
			else {
				p = tail;
				for (int j = _size - 1; j >= i; j--) p = p->prev;
			}
			return p->value;
		}
};
```