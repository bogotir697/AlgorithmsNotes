#### [[Вопросы к Экзамену]]
---
Все эти алгоритмы объединяет то, что они являются не сравнительными алгоритмами сортировки.
### Блочная сортировка
**Основная идея:** Алгоритм разбивает массив данных на блоки, содержащие диапазон элементов. После рекурсивно повторяет сортировку.
**Алгоритм:**
1. Найти размер, диапазон значений
2. Если диапазон значений равен единице, выйти
3. Разбросать элементы массива по корзинам
4. Рекурсивно отсортировать корзины
5. Переложить элементы в массив в правильном порядке
```python
def bucketSort(arr):
  n = len(arr)
  k = n // 2
  min_val = min(arr)
  d = max(arr) - min_val + 1
  if d <= 1:
    return 
  buckets = [[] for _ in range(k)]
  for x in arr:
    i = (x - min_val) * k // d
    buckets[i].append(x)
  for bucket in buckets:
    bucketSort(bucket)
  i = 0
  for bucket in buckets:
    for x in bucket:
      arr[i] = x
      i += 1
```
### Сортировка подсчётом
**Основная идея:** Алгоритм подсчитывает количество элементов с каждым возможным значением ключа, а затем вычисляет позиции элементов в отсортированном массиве.
**Временная сложность:** $O(n + k)$, где n — размер исходного массива, а k — диапазон значений.
**Пространственная сложность:** $O(n+k)$
**Алгоритм:**
1. Найти диапазон значений, то есть минимальный и максимальный элемент. Диапазон вычисляется так: `k = max_val - min_val + 1`.
2. Создать массив для подсчёта размера `k`: `count = [0]*k`, — где `i` соответствует элементу со значением `i + min_val`.
3. Подсчитать количество каждого элемента.
4. Преобразовать массив для подсчёта в массив префиксных сумм (кумулятивный массив). Для этого начиная со 2-го элемента складываем его значение в массиве с предыдущим: `count[i] = count[i-1] + count[i] # for i in range(1,k)`.
5. Разместить элементы в выходном массиве. Для этого, начиная с конца исходного массива, перебираем все элементы. На каждой итерации обращаемся к соответствующему значению `j = arr[i] - min_val` кумулятивного массива, полученное значение `count[j] - 1` является индексом для элемента, с которым работаем в данный момент. Помещаем элемент по соответствующему индексу и уменьшаем значение в кумулятивном массиве `count[j] -= 1`.
#### Пример
Исходный массив: `[4,2,2,8,3,3,1]`.
1. `max_val = max(arr) # 8`, `min_val = min(arr) # 1`, `k = max_val - min_val + 1 # 8`.
2. `count = [0]*k # [0,0,0,0,0,0,0,0]`. 
3. ```
   Элемент 4 → индекс 3 (4-1) → count[3]++
   Элемент 2 → индекс 1 (2-1) → count[1]++
   Элемент 2 → индекс 1 → count[1]++
   Элемент 8 → индекс 7 → count[7]++
   Элемент 3 → индекс 2 → count[2]++
   Элемент 3 → индекс 2 → count[2]++
   Элемент 1 → индекс 0 → count[0]++
   # count = [1,2,2,1,0,0,0,1]
   ```
   
4. ```
   count[0] = 1  (элементы со значением 1 займут позиции 0...0)
   count[1] = 1 + 2 = 3  (элементы со значением 2 займут позиции 1...2)
   count[2] = 3 + 2 = 5  (элементы со значением 3 займут позиции 3...4)
   count[3] = 5 + 1 = 6  (элементы со значением 4 займут позицию 5)
   count[4] = 6 + 0 = 6
   count[5] = 6 + 0 = 6
   count[6] = 6 + 0 = 6
   count[7] = 6 + 1 = 7  (элементы со значением 8 займут позицию 6)
   # count = [1,3,5,6,6,6,7]
   ```
   
5. Исходный: `[4, 2, 2, 8, 3, 3, 1]`. Выходной: `[0, 0, 0, 0, 0, 0, 0]`. 
	1. Элемент `1` (последний в исходном)
	    - Индекс в count: `1 - 1 = 0`        
	    - `count[0] = 1` → позиция в выходном: `1 - 1 = 0`
	    - Размещаем `1` на позицию 0, уменьшаем `count[0]` до 0
	    - Выходной: `[1, 0, 0, 0, 0, 0, 0]`
	2. Элемент `3`
	    - Индекс: `3 - 1 = 2`
	    - `count[2] = 5` → позиция: `5 - 1 = 4`
	    - Выходной: `[1, 0, 0, 0, 3, 0, 0]`, `count[2] = 4`
	3. Элемент `3` (второй)
	    - Индекс: `2`    
	    - `count[2] = 4` → позиция: `4 - 1 = 3`
	    - Выходной: `[1, 0, 0, 3, 3, 0, 0]`, `count[2] = 3`
	4. Элемент `8`
	    - Индекс: `7`
	    - `count[7] = 7` → позиция: `7 - 1 = 6`
	    - Выходной: `[1, 0, 0, 3, 3, 0, 8]`, `count[7] = 6`
	5. Элемент `2`
	    - Индекс: `1`
	    - `count[1] = 3` → позиция: `3 - 1 = 2`
	    - Выходной: `[1, 0, 2, 3, 3, 0, 8]`, `count[1] = 2`
	6. Элемент `2` (второй)
	    - Индекс: `1`
	    - `count[1] = 2` → позиция: `2 - 1 = 1`
	    - Выходной: `[1, 2, 2, 3, 3, 0, 8]`, `count[1] = 1`
	7. Элемент `4`
	    - Индекс: `3`
	    - `count[3] = 6` → позиция: `6 - 1 = 5`
	    - Выходной: `[1, 2, 2, 3, 3, 4, 8]`, `count[3] = 5`

**Результат:** `[1, 2, 2, 3, 3, 4, 8]`
#### Реализация
```python
def counting_sort(arr):
  if not arr:
    return arr
  
  # Шаг 1: Находим минимальное и максимальное значения
  min_val = min(arr)
  max_val = max(arr)
  
  # Шаг 2: Создаём массив для подсчёта
  k = max_val - min_val + 1
  count = [0] * k
  
  # Шаг 3: Подсчитываем количество каждого элемента
  for num in arr:
    count[num - min_val] += 1
  
  # Шаг 4: Преобразуем count в префиксные суммы
  for i in range(1, k):
    count[i] += count[i - 1]
  
  # Шаг 5: Создаём выходной массив и размещаем элементы
  output = [0] * len(arr)
  
  # Идём с конца для сохранения устойчивости
  for i in range(len(arr) - 1, -1, -1):
    num = arr[i]
    index = num - min_val
    position = count[index] - 1
    output[position] = num
    count[index] -= 1
  
  return output
```
### Поразрядная сортировка
**Основная идея:** Вместо сравнения элементов между собой (как в быстрой или сортировке слиянием), поразрядная сортировка распределяет элементы по "корзинам" (bucket'ам) в зависимости от значения текущего обрабатываемого разряда (единицы, десятки, сотни и т.д. для чисел; или символы для строк).
**Временная сложность:** $O(d*(n+k))$, где $n$ — количество элементов, $k$ — основание системы счисления, $d$ — максимальное количество разрядов в самом длинном числе.
**Пространственная сложность:** $O(n+k)$.
Существует две разновидности этой сортировки: 
1. **LSD** (Least Significant Digit) 
- Сортировка начинается с самого правого (младшего) разряда и продвигается к самому левому (старшему)
	1. Найти максимальное число
	2. Создать вспомогательный массив для подсчёта размером равным основанию системы счисления
	3. Выбрать младший разряд
	4. Увеличивать соответствующее разряду значение в массиве подсчёта
	5. Преобразовать массив подсчёта в подобие кумулятивного массив. В отличие от массива префиксных сумм, в котором на каждой позиции хранится `индекс элемента + 1`, начиная с последнего, тут на каждой позиции хранится `индекс элемента`, начиная с первого. Соответственно значение в ячейке после добавления элемента не уменьшается, а увеличивается.
	6. Пользуясь массивом индексов расположить значения изначального массива по соответствующим позициям
	7. Очистить вспомогательный массив
	8. Перейти к следующему разряду
	9. Повторять пункты 4-7 до тех пор, пока у максимального числа не закончатся разряды
- ```python
  def radixSortLSD(arr):
    max_val = max(arr)
    base = 10
    count = [0]*base
    exp = 1
    while max_val // exp > 0:
      # выполняем сортировку подсчётом
      for n in arr:
        d = (n // exp) % base
        count[d] += 1
      cnt = 0
      # преобразуем массив в массив индексов
      for i in range(base):
        tmp = count[i]
        count[i] = cnt
        cnt += tmp
      # располагаем значения по нужным позициям
      new_arr = [0]*len(arr)
      for n in arr:
        d = (n // exp) % base
        new_arr[count[d]] = n
        count[d] += 1
      arr = new_arr
      exp *= base
      count = [0]*base
    return arr
  ```
2. **MSD** (Most Significant Digit) 
- Сортировка начинается с самого левого (старшего) разряда и продвигается к самому правому (младшему)
	1. Найти максимальное число. 
	2. Создать вспомогательный массив для подсчёта размером равным основанию системы счисления
	3. Выбрать разряд `d`, считая слева направо c единицы (для первого шага `d = 1`)
	4. Увеличивать соответствующее разряду значение в массиве подсчёта
	5. Преобразовать массив подсчёта в кумулятивный.
	6. Пользуясь кумулятивным массивом расположить значения изначального массива по соответствующим позициям
	7. Рекурсивно выполнять сортировку для каждой корзины `[l, r]` и `d = d + 1`. `l = l + count[i - 1]; r = l + count[i] - 1`. Остановка происходит, когда `l >= r` или `d > m`. То есть, когда размер корзины становится `<= 1` или когда мы уже рассмотрели последний разряд.
- ```python
  def radixSort(arr, l, r, d):
    m = len(str(max(arr)))
    k = 10
    if d > m or l >= r: # если
      return
    # создаём вспомогательный массив подсчёта
    cnt = [0]*k
    # выполняем сортировку подсчётом
    for i in range(l, r + 1):
      j = (arr[i] // k ** (m - d)) % k
      cnt[j] += 1
    # преобразуем массив в кумулятивный
    for j in range(1, k + 1):
      cnt[j] += cnt[j - 1]
    # располагаем значения в нужных позициях
    c = [0]*len(arr)
    for i in range(l, r + 1):
      j = (arr[i] // k ** (m - d)) % k
      cnt[j] -= 1
      c[l + cnt[j]] = arr[i]
    for i in range(l, r + 1):
      arr[i] = c[i]
    # рекурсивно сортируем корзины для следующих разрядов
    radixSort(arr, l, l + cnt[0] - 1, d + 1)
    for i in range(1, k + 1):
      radixSort(arr, l + cnt[i - 1], l + cnt[i] - 1, d + 1)
  ```
