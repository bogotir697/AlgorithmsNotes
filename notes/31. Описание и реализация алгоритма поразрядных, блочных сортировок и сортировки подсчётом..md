#### [[Вопросы к Экзамену]]
---
Все эти алгоритмы объединяет то, что они являются не сравнительными алгоритмами сортировки.
### Сортировка подсчётом
**Основная идея:** Алгоритм подсчитывает количество элементов с каждым возможным значением ключа, а затем вычисляет позиции элементов в отсортированном массиве.
**Временная сложность:** $O(n + k)$ 
Алгоритм:
1. Найти диапазон значений, то есть минимальный и максимальный элемент. Диапазон вычисляется так: `k = max_val - min_val + 1`.
2. Создать массив для подсчёта размера `k`: `count = [0]*k`, — где `i` соответствует элементу со значением `i + min_val`.
3. Подсчитать количество каждого элемента.
4. Преобразовать массив для подсчёта в массив префиксных сумм (кумулятивный массив). Для этого начиная со 2-го элемента складываем его значение в массиве с предыдущим: `count[i] = count[i-1] + count[i] # for i in range(1,k)`.
5. Разместить элементы в выходном массиве. Для этого, начиная с конца исходного массива, перебираем все элементы. На каждой итерации обращаемся к соответствующему значению `j = arr[i] - min_val` кумулятивного массива, полученное значение `count[j] - 1` является индексом для элемента, с которым работаем в данный момент. Помещаем элемент по соответствующему индексу и уменьшаем значение в кумулятивном массиве `count[j] -= 1`.
#### Пример
Исходный массив: `[4,2,2,8,3,3,1]`.
1. `max_val = max(arr) # 8`, `min_val = min(arr) # 1`, `k = max_val - min_val + 1 # 8`.
2. `count = [0]*k # [0,0,0,0,0,0,0,0]`. 
3. ```
   Элемент 4 → индекс 3 (4-1) → count[3]++
   Элемент 2 → индекс 1 (2-1) → count[1]++
   Элемент 2 → индекс 1 → count[1]++
   Элемент 8 → индекс 7 → count[7]++
   Элемент 3 → индекс 2 → count[2]++
   Элемент 3 → индекс 2 → count[2]++
   Элемент 1 → индекс 0 → count[0]++
   # count = [1,2,2,1,0,0,0,1]
   ```
   
4. ```
   count[0] = 1  (элементы со значением 1 займут позиции 0...0)
   count[1] = 1 + 2 = 3  (элементы со значением 2 займут позиции 1...2)
   count[2] = 3 + 2 = 5  (элементы со значением 3 займут позиции 3...4)
   count[3] = 5 + 1 = 6  (элементы со значением 4 займут позицию 5)
   count[4] = 6 + 0 = 6
   count[5] = 6 + 0 = 6
   count[6] = 6 + 0 = 6
   count[7] = 6 + 1 = 7  (элементы со значением 8 займут позицию 6)
   # count = [1,3,5,6,6,6,7]
   ```
   
5. Исходный: `[4, 2, 2, 8, 3, 3, 1]`. Выходной: `[0, 0, 0, 0, 0, 0, 0]`. 
	1. Элемент `1` (последний в исходном)
	    - Индекс в count: `1 - 1 = 0`        
	    - `count[0] = 1` → позиция в выходном: `1 - 1 = 0`
	    - Размещаем `1` на позицию 0, уменьшаем `count[0]` до 0
	    - Выходной: `[1, 0, 0, 0, 0, 0, 0]`
	2. Элемент `3`
	    - Индекс: `3 - 1 = 2`
	    - `count[2] = 5` → позиция: `5 - 1 = 4`
	    - Выходной: `[1, 0, 0, 0, 3, 0, 0]`, `count[2] = 4`
	3. Элемент `3` (второй)
	    - Индекс: `2`    
	    - `count[2] = 4` → позиция: `4 - 1 = 3`
	    - Выходной: `[1, 0, 0, 3, 3, 0, 0]`, `count[2] = 3`
	4. Элемент `8`
	    - Индекс: `7`
	    - `count[7] = 7` → позиция: `7 - 1 = 6`
	    - Выходной: `[1, 0, 0, 3, 3, 0, 8]`, `count[7] = 6`
	5. Элемент `2`
	    - Индекс: `1`
	    - `count[1] = 3` → позиция: `3 - 1 = 2`
	    - Выходной: `[1, 0, 2, 3, 3, 0, 8]`, `count[1] = 2`
	6. Элемент `2` (второй)
	    - Индекс: `1`
	    - `count[1] = 2` → позиция: `2 - 1 = 1`
	    - Выходной: `[1, 2, 2, 3, 3, 0, 8]`, `count[1] = 1`
	7. Элемент `4`
	    - Индекс: `3`
	    - `count[3] = 6` → позиция: `6 - 1 = 5`
	    - Выходной: `[1, 2, 2, 3, 3, 4, 8]`, `count[3] = 5`

**Результат:** `[1, 2, 2, 3, 3, 4, 8]`
#### Реализация
```python
def counting_sort(arr):
    if not arr:
        return arr
    
    # Шаг 1: Находим минимальное и максимальное значения
    min_val = min(arr)
    max_val = max(arr)
    
    # Шаг 2: Создаём массив для подсчёта
    k = max_val - min_val + 1
    count = [0] * k
    
    # Шаг 3: Подсчитываем количество каждого элемента
    for num in arr:
        count[num - min_val] += 1
    
    # Шаг 4: Преобразуем count в префиксные суммы
    for i in range(1, k):
        count[i] += count[i - 1]
    
    # Шаг 5: Создаём выходной массив и размещаем элементы
    output = [0] * len(arr)
    
    # Идём с конца для сохранения устойчивости
    for i in range(len(arr) - 1, -1, -1):
        num = arr[i]
        index = num - min_val
        position = count[index] - 1
        output[position] = num
        count[index] -= 1
    
    return output
```
### Поразрядная сортировка
**Основная идея:** Вместо сравнения элементов между собой (как в быстрой или сортировке слиянием), поразрядная сортировка распределяет элементы по "корзинам" (bucket'ам) в зависимости от значения текущего обрабатываемого разряда (единицы, десятки, сотни и т.д. для чисел; или символы для строк).