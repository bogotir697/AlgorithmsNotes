#### [[Вопросы к Экзамену]]
---
### Описание
Идея пирамидальной сортировки заключается в использовании такой структуры данных, как [бинарная куча](https://ru.wikipedia.org/wiki/Куча_\(структура_данных\)), являющаяся бинарным деревом со следующими ограничениями:

1. Значение в любом узле не меньше, чем в любом из его потомков
2. Бинарное дерево является полным

Для представления дерева через массив можно использовать следующую идею: на первой позиции находится корень бинарного дерева, тогда для каждого потомка будет верно, что его индекс определяется как $2n+1$ для левого потомка и $2n+2$ для правого потомка:
<div style="background-color:white; display:flex; width:fit-content; border-radius: 10px">
	<div style="margin: 5px">
		<img src="../img/heap.png">
	</div>
</div>
Алгоритм сводится к следующим шагам:

1. Элементы входной последовательности необходимо переставить таким образом, чтобы они удовлетворяли условиям для бинарной кучи
2. Обменять первый элемент с последним, убрать из рассмотрения данных элемент и выполнить операцию по восстановлению бинарной кучи, т.к. после обмена полученное дерево может не соответствовать ограничению 1
### Сложность
Худшее время: $O(n\log{n})$
В среднем: $O(n\log{n})$
Лучшее время: $O(n\log{n})$
### Реализация
``` python
def heapify(a: list[...], heapSize: int, i: int):
	while true:
		left = 2 * i + 1
		right = 2 * i + 2
		largest = i
		if a[left] > a[largest] and left < heapSize:
			largest = left
		if a[right] > a[largest] and right < heapSize:
			largest = right
		if largest != i:
			a[i], a[largest] = a[largest], a[i] # swap a[i] and a[largest]
			i = largest
		else
			break

def buildHeap(a: list[...]):
	for i in range((len(a) - 1) // 2, 0, -1):
		heapify(a, len(a), i)

def heapSort(a: list[...]): # sort function
	buildHeap(a)
	for i in range(len(a) - 1, 0, -1):
		a[i], a[0] = a[0], a[i] # swap a[i] and a[0]
		heapify(a, i, 0)
```
