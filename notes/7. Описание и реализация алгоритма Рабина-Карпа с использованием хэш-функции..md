#### [[Вопросы к Экзамену]]
---
### Описание
Алгоритм использует хэширование для поиска подстроки в тексте. Он был разработан в 1987 году Михаэлем Рабином и Ричардом Карпом Алгоритм редко используется для поиска одиночного шаблона, но имеет значительную теоретическую важность и очень эффективен в поиске совпадений множественных шаблонов одинаковой длины.
Алгоритм использует тот факт, что если строки равны, то и их хэш-значения равны. Но существует две проблемы: 
1. Так как существует множество строк, между двумя различными может произойти коллиизия: совпадение их хэшей, - поэтому приходится проверять, действительно ли строки равны
2. Пересчитывание хэша, в наивном пересчёте оно затрачивает время $\Omega(m)$

Но обе эти проблемы не очень сложно решаются. Для решения первой достаточно проверять равенство строк при равестве хэша, а для решения второй нужно использовать кольцевой хэш. Самым простым примером кольцевого хэша является добавление значений каждого следующего символа в подстроке и последующее использование данной формулы для подсчёта каждого следующего хеш-значения за фиксированное время: 
```
s[i+1..i+m] = s[i..i+m-1] - s[i] + s[i+m]
```
Также одним и способов избежать первой проблемы является использование хорошей хэш-функции, например, использовать полиномиальный хэш: 
$$hash(p[1..m]) = \left(\displaystyle\sum_{i=1}^{m}{p[i]x^{m-i}}\right)\mod{q}$$
### Реализация
```python
x = 101
q = 2**31 - 1
def makeHash(s: str) -> int:
	hs = 0;
	for c in s:
		hs = hs * x + ord(c)
	hs = hs % q
	return hs

def remakeHash(oldHash: int, s: str, i: int, m: int) -> int:
	hs = (oldHash - ord(s[i])*x**(m - 1))*x + ord(s[i + m]) % q
	return hs

def RabinKarp(s: str, sub: str):
	hsub = hash(sub)
	hs = hash(s[:m])
	for i in range(len(s) - len(sub) + 1):
		if hs == hsub:
			if s[i:i+len(sub)] == sub:
				return i
		hs = remakeHash(hs, s, i, len(sub))
	return -1
```